/// Day 5 Part 2: Merge overlapping ranges and count total coverage
///
/// Input format: Lines of "start-end" ranges, followed by blank line, then IDs (ignored).
/// Output: Sum of coverage across all merged disjoint ranges.
///
/// Two ranges overlap or touch if: end1 + 1 >= start2 AND end2 + 1 >= start1
pub module Day05 #(
    param BYTES: u32 = 1,
) (
    clk: input clock,
    rst: input reset,

    i_data     : input  logic<BYTES, 8>          ,
    i_available: input  logic<$clog2(BYTES + 1)> ,
    o_consumed : output logic<$clog2(BYTES + 1)> ,
    o_finished : output logic                    ,
    o_answer   : output logic<64>                ,
) {
    // Map new interface to internal signals
    let i_byte : logic<8> = i_data[0];
    let i_valid: logic    = i_available != 0;
    var o_busy : logic;

    // Output mapping
    always_comb {
        o_consumed = i_available;
        if o_busy {
            o_consumed = 0;
        }
        o_finished = solver_valid;
    }

    var decoder_start      : logic<64>;
    var decoder_end        : logic<64>;
    var decoder_range_valid: logic    ;
    var decoder_done       : logic    ;
    var decoder_busy       : logic    ;
    var solver_busy        : logic    ;
    var solver_valid       : logic    ;

    inst decoder: Day05Decoder (
        clk                               ,
        rst                               ,
        i_data       : i_byte             ,
        i_valid                           ,
        i_busy       : solver_busy        ,
        o_start      : decoder_start      ,
        o_end        : decoder_end        ,
        o_range_valid: decoder_range_valid,
        o_done       : decoder_done       ,
        o_busy       : decoder_busy       ,
    );

    inst solver: Day05Solver (
        clk                               ,
        rst                               ,
        i_start      : decoder_start      ,
        i_end        : decoder_end        ,
        i_range_valid: decoder_range_valid,
        i_done       : decoder_done       ,
        o_answer                          ,
        o_busy       : solver_busy        ,
        o_valid      : solver_valid       ,
    );

    assign o_busy = decoder_busy;
}

/// Parses "start-end" lines from input stream.
/// Emits (start, end) pairs, signals done after blank line and end of input.
module Day05Decoder (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,
    i_busy : input logic   ,

    o_start      : output logic<64>,
    o_end        : output logic<64>,
    o_range_valid: output logic    ,
    o_done       : output logic    ,
    o_busy       : output logic    ,
) {
    enum State: logic<3> {
        ParseStart,
        ParseEnd,
        EmitRange,
        Consume,
        Done,
    }

    var state     : State    ;
    var start_val : logic<64>;
    var end_val   : logic<64>;
    var prev_valid: logic    ;

    var is_digit  : logic   ;
    var is_dash   : logic   ;
    var is_newline: logic   ;
    var digit_val : logic<4>;

    always_comb {
        is_digit   = i_data >= "0" && i_data <= "9";
        is_dash    = i_data == "-";
        is_newline = i_data == 8'h0A;
        digit_val  = i_data[3:0];
    }

    always_ff {
        if_reset {
            state      = State::ParseStart;
            start_val  = 0;
            end_val    = 0;
            prev_valid = 0;
        } else {
            prev_valid = i_valid;

            case state {
                State::ParseStart: {
                    if i_valid {
                        if is_digit {
                            start_val = start_val * 10 + {60'b0, digit_val};
                        } else if is_dash {
                            state = State::ParseEnd;
                        } else if is_newline && start_val == 0 {
                            state = State::Consume;
                        }
                    }
                }

                State::ParseEnd: {
                    if i_valid {
                        if is_digit {
                            end_val = end_val * 10 + {60'b0, digit_val};
                        } else if is_newline {
                            state = State::EmitRange;
                        }
                    }
                }

                State::EmitRange: {
                    if !i_busy {
                        end_val = 0;

                        // Process incoming character to avoid data loss during handshake
                        if i_valid && is_digit {
                            start_val = {60'b0, digit_val};
                            state     = State::ParseStart;
                        } else if i_valid && is_newline {
                            start_val = 0;
                            state     = State::Consume;
                        } else {
                            start_val = 0;
                            state     = State::ParseStart;
                        }
                    }
                }

                State::Consume: {
                    if !i_valid && prev_valid {
                        state = State::Done;
                    }
                }

                default: {}
            }
        }
    }

    always_comb {
        o_start       = start_val;
        o_end         = end_val;
        o_range_valid = state == State::EmitRange;
        o_done        = state == State::Done;
        o_busy        = state == State::EmitRange && i_busy;
    }
}

/// Merges overlapping ranges and counts total coverage.
/// Maintains up to 128 disjoint ranges in parallel arrays with occupancy bitmask.
module Day05Solver (
    clk: input clock,
    rst: input reset,

    i_start      : input logic<64>,
    i_end        : input logic<64>,
    i_range_valid: input logic    ,
    i_done       : input logic    ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    const MAX_RANGES: u32 = 128;

    enum State: logic<3> {
        Idle,
        ScanOverlap,
        MergeOne,
        FindSlot,
        Insert,
        CountInit,
        CountScan,
        Done,
    }

    var state: State;

    var ranges_start: logic<64>         [MAX_RANGES];
    var ranges_end  : logic<64>         [MAX_RANGES];
    var occupied    : logic<MAX_RANGES>             ;

    var cur_start: logic<64>        ;
    var cur_end  : logic<64>        ;
    var scan_mask: logic<MAX_RANGES>;

    var prev_range_valid  : logic            ;
    var range_valid_rising: logic            ;
    var overlap_mask      : logic<MAX_RANGES>;
    var first_overlap_idx : logic<7>         ;
    var has_overlap       : logic            ;
    var first_empty_idx   : logic<7>         ;
    var has_empty         : logic            ;
    var first_occupied_idx: logic<7>         ;
    var has_occupied      : logic            ;
    var count_mask        : logic<MAX_RANGES>;
    var answer            : logic<64>        ;

    always_comb {
        range_valid_rising = i_range_valid && !prev_range_valid;
    }

    // Overlap detection: ranges overlap or touch if end1+1 >= start2 AND end2+1 >= start1
    always_comb {
        for i: u32       in 0..MAX_RANGES {
            let slot_end_plus1   : logic<64> = ranges_end[i] + 1;
            let cur_end_plus1    : logic<64> = cur_end + 1;
            let overlaps_or_touch: logic     = (slot_end_plus1 >= cur_start) && (cur_end_plus1 >= ranges_start[i]);
            overlap_mask[i]   = occupied[i] && scan_mask[i] && overlaps_or_touch;
        }
    }

    // Priority encoder: first overlapping slot
    always_comb {
        first_overlap_idx = 0;
        has_overlap       = 0;
        for i: u32 in 0..MAX_RANGES {
            if overlap_mask[i] && !has_overlap {
                first_overlap_idx = i[6:0];
                has_overlap       = 1;
            }
        }
    }

    // Priority encoder: first empty slot
    always_comb {
        first_empty_idx = 0;
        has_empty       = 0;
        for i: u32 in 0..MAX_RANGES {
            if !occupied[i] && !has_empty {
                first_empty_idx = i[6:0];
                has_empty       = 1;
            }
        }
    }

    // Priority encoder: first occupied slot (for counting)
    always_comb {
        first_occupied_idx = 0;
        has_occupied       = 0;
        for i: u32 in 0..MAX_RANGES {
            if count_mask[i] && !has_occupied {
                first_occupied_idx = i[6:0];
                has_occupied       = 1;
            }
        }
    }

    always_ff {
        if_reset {
            state            = State::Idle;
            occupied         = 0;
            cur_start        = 0;
            cur_end          = 0;
            scan_mask        = 0;
            count_mask       = 0;
            answer           = 0;
            prev_range_valid = 0;
            ranges_start     = '{default: 0};
            ranges_end       = '{default: 0};
        } else {
            if state == State::Idle {
                prev_range_valid = i_range_valid;
            }

            case state {
                State::Idle: {
                    if range_valid_rising {
                        cur_start        = i_start;
                        cur_end          = i_end;
                        scan_mask        = ~128'b0;
                        state            = State::ScanOverlap;
                        prev_range_valid = 0;
                    } else if i_done {
                        state = State::CountInit;
                    }
                }

                State::ScanOverlap: {
                    if has_overlap {
                        state = State::MergeOne;
                    } else {
                        state = State::FindSlot;
                    }
                }

                State::MergeOne: {
                    let idx: logic<7> = first_overlap_idx;
                    if ranges_start[idx] <: cur_start {
                        cur_start = ranges_start[idx];
                    }
                    if ranges_end[idx] >: cur_end {
                        cur_end = ranges_end[idx];
                    }
                    occupied[idx]  = 0;
                    scan_mask[idx] = 0;
                    state          = State::ScanOverlap;
                }

                State::FindSlot: {
                    if has_empty {
                        state = State::Insert;
                    } else {
                        state = State::Idle;
                    }
                }

                State::Insert: {
                    let idx              : logic<7> = first_empty_idx;
                    ranges_start[idx] = cur_start;
                    ranges_end[idx]   = cur_end;
                    occupied[idx]     = 1;
                    state             = State::Idle;
                }

                State::CountInit: {
                    count_mask = occupied;
                    answer     = 0;
                    state      = State::CountScan;
                }

                State::CountScan: {
                    if has_occupied {
                        let idx            : logic<7>  = first_occupied_idx;
                        let size           : logic<64> = ranges_end[idx] - ranges_start[idx] + 1;
                        answer          = answer + size;
                        count_mask[idx] = 0;
                    } else {
                        state = State::Done;
                    }
                }

                default: {}
            }
        }
    }

    always_comb {
        o_answer = answer;
        o_busy   = state != State::Idle && state != State::Done;
        o_valid  = state == State::Done;
    }
}

#[test(test_day_05)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_05;
        localparam string   FILENAME = "day_05.txt";
        localparam longint  EXPECTED = 64'd14;
        localparam longint  TIMEOUT  = 100000;

        localparam BYTES    = 1;
        localparam IDX_BITS = $clog2(BYTES + 1);

        logic clk, rst;
        longint cycle_count;

        logic [BYTES-1:0][7:0] i_data;
        logic [IDX_BITS-1:0] i_available;
        logic [IDX_BITS-1:0] o_consumed;
        logic o_finished;
        logic [63:0] o_answer;

        aoc_Day05 #(.BYTES(BYTES)) dut (
            .clk(clk), .rst(rst),
            .i_data(i_data), .i_available(i_available),
            .o_consumed(o_consumed), .o_finished(o_finished),
            .o_answer(o_answer)
        );

        initial begin clk = 0; forever #0.5 clk = ~clk; end

        `include "aoc_tasks.svh"

        initial begin
            aoc_init();
            aoc_run_test(FILENAME, TIMEOUT, cycle_count);
            aoc_verify(EXPECTED, cycle_count);
            $finish;
        end
    endmodule
}}}
