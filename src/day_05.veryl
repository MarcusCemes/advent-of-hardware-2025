/// Day 05: Range Merger
///
/// Parses ranges (e.g., "3-5", "10-14") from input and merges overlapping ranges,
/// then counts total coverage.
///
/// IMPORTANT: This solution requires BYTES to be large enough to encompass an entire
/// line at once (processes one line per cycle). The decoder assumes the full range
/// specification (e.g., "123-456\n") fits within a single BYTES-wide input buffer.
/// With the default BYTES=32 in the decoder, lines up to 32 characters are supported.
pub module Day05 #(
    param BYTES: u32 = 32,
) (
    clk: input clock,
    rst: input reset,

    i_available: input logic<IDX_BITS>,
    i_data     : input logic<BYTES, 8>,
    i_eof      : input logic          ,

    o_consumed: output logic<IDX_BITS>,
    o_finished: output logic          ,
    o_answer  : output logic<64>      ,
) {
    const IDX_BITS: u32 = $clog2(BYTES + 1);

    var decoder_done : logic    ;
    var decoder_end  : logic<64>;
    var decoder_start: logic<64>;
    var decoder_valid: logic    ;
    var solver_busy  : logic    ;

    inst decoder: Day05Decoder (
        clk                       ,
        rst                       ,
        i_available               ,
        i_busy     : solver_busy  ,
        i_data                    ,
        i_eof                     ,
        o_consumed                ,
        o_done     : decoder_done ,
        o_end      : decoder_end  ,
        o_start    : decoder_start,
        o_valid    : decoder_valid,
    );

    inst solver: Day05Solver (
        clk                      ,
        rst                      ,
        i_done    : decoder_done ,
        i_end     : decoder_end  ,
        i_start   : decoder_start,
        i_valid   : decoder_valid,
        o_answer                 ,
        o_busy    : solver_busy  ,
        o_finished               ,
    );
}

module Day05Decoder #(
    param BYTES : u32 = 32,
    param DIGITS: u32 = 15,
) (
    clk: input clock,
    rst: input reset,

    i_available: input logic<IDX_BITS>,
    i_busy     : input logic          ,
    i_data     : input logic<BYTES, 8>,
    i_eof      : input logic          ,

    o_consumed: output logic<IDX_BITS>,
    o_done    : output logic          ,
    o_end     : output logic<64>      ,
    o_start   : output logic<64>      ,
    o_valid   : output logic          ,
) {
    const IDX_BITS: u32 = $clog2(BYTES + 1);

    enum State: logic {
        Parse,
        Done,
    }

    var consumed: logic<IDX_BITS>;
    var values  : logic<2, 64>   ;
    var valid   : logic          ;

    inst parser: ParseNumbers #(
        BYTES              ,
        COUNT      : 2     ,
        MAX_DIGITS : DIGITS,
        SEPARATOR  : 8'h2D , // '-'
        OUTPUT_BITS: 64    ,
    ) (
        i_available          ,
        i_data               ,
        o_consumed : consumed,
        o_valid    : valid   ,
        o_values   : values  ,
    );

    // Output signals
    always_comb {
        // Halt once we hit the double newline (first is consumed)
        o_done = i_available != '0 && i_data[0] == 8'h0A; // '\n'

        o_start = values[0];
        o_end   = values[1];
        o_valid = valid && !o_done;

        o_consumed = 0;

        if !i_busy {
            o_consumed = consumed;
        }
    }
}

/// Merges overlapping ranges and counts total coverage.
/// Maintains up to 128 disjoint ranges in parallel arrays with occupancy bitmask.
module Day05Solver (
    clk: input clock,
    rst: input reset,

    i_done : input logic    ,
    i_end  : input logic<64>,
    i_start: input logic<64>,
    i_valid: input logic    ,

    o_answer  : output logic<64>,
    o_busy    : output logic    ,
    o_finished: output logic    ,
) {
    const MAX_RANGES: u32 = 128;

    enum State: logic<3> {
        Idle,
        ScanOverlap,
        MergeOne,
        FindSlot,
        Insert,
        CountInit,
        CountScan,
        Done,
    }

    var state: State;

    var ranges_start: logic<64>         [MAX_RANGES];
    var ranges_end  : logic<64>         [MAX_RANGES];
    var occupied    : logic<MAX_RANGES>             ;

    var cur_start: logic<64>        ;
    var cur_end  : logic<64>        ;
    var scan_mask: logic<MAX_RANGES>;

    var overlap_mask      : logic<MAX_RANGES>;
    var first_overlap_idx : logic<7>         ;
    var has_overlap       : logic            ;
    var first_empty_idx   : logic<7>         ;
    var has_empty         : logic            ;
    var first_occupied_idx: logic<7>         ;
    var has_occupied      : logic            ;
    var count_mask        : logic<MAX_RANGES>;
    var answer            : logic<64>        ;

    always_ff {
        if_reset {
            state        = State::Idle;
            occupied     = '0;
            cur_start    = '0;
            cur_end      = '0;
            scan_mask    = '0;
            count_mask   = '0;
            answer       = '0;
            ranges_start = '{default: '0};
            ranges_end   = '{default: '0};

        } else {
            case state {
                State::Idle: {
                    if i_done {
                        state = State::CountInit;

                    } else if i_valid {
                        cur_start = i_start;
                        cur_end   = i_end;
                        scan_mask = ~128'b0;
                        state     = State::ScanOverlap;
                    }
                }

                State::ScanOverlap: {
                    if has_overlap {
                        state = State::MergeOne;
                    } else {
                        state = State::FindSlot;
                    }
                }

                State::MergeOne: {
                    let idx: logic<7> = first_overlap_idx;

                    if ranges_start[idx] <= cur_start {
                        cur_start = ranges_start[idx];
                    }

                    if ranges_end[idx] >= cur_end {
                        cur_end = ranges_end[idx];
                    }

                    occupied[idx]  = 0;
                    scan_mask[idx] = 0;
                    state          = State::ScanOverlap;
                }

                State::FindSlot: {
                    if has_empty {
                        state = State::Insert;
                    } else {
                        state = State::Idle;
                    }
                }

                State::Insert: {
                    let idx              : logic<7> = first_empty_idx;
                    ranges_start[idx] = cur_start;
                    ranges_end[idx]   = cur_end;
                    occupied[idx]     = 1;
                    state             = State::Idle;
                }

                State::CountInit: {
                    count_mask = occupied;
                    answer     = 0;
                    state      = State::CountScan;
                }

                State::CountScan: {
                    if has_occupied {
                        let idx            : logic<7>  = first_occupied_idx;
                        let size           : logic<64> = ranges_end[idx] - ranges_start[idx] + 1;
                        answer          = answer + size;
                        count_mask[idx] = 0;

                    } else {
                        state = State::Done;
                    }
                }

                default: {}
            }
        }
    }

    // Overlap detection: ranges overlap or touch if end1+1 >= start2 AND end2+1 >= start1
    always_comb {
        for i: u32       in 0..MAX_RANGES {
            let slot_end_plus1   : logic<64> = ranges_end[i] + 1;
            let cur_end_plus1    : logic<64> = cur_end + 1;
            let overlaps_or_touch: logic     = (slot_end_plus1 >= cur_start) && (cur_end_plus1 >= ranges_start[i]);
            overlap_mask[i]   = occupied[i] && scan_mask[i] && overlaps_or_touch;
        }
    }

    // Priority encoder: first overlapping slot
    always_comb {
        first_overlap_idx = 0;
        has_overlap       = 0;
        for i: u32 in 0..MAX_RANGES {
            if overlap_mask[i] && !has_overlap {
                first_overlap_idx = i[6:0];
                has_overlap       = 1;
            }
        }
    }

    // Priority encoder: first empty slot
    always_comb {
        first_empty_idx = 0;
        has_empty       = 0;
        for i: u32 in 0..MAX_RANGES {
            if !occupied[i] && !has_empty {
                first_empty_idx = i[6:0];
                has_empty       = 1;
            }
        }
    }

    // Priority encoder: first occupied slot (for counting)
    always_comb {
        first_occupied_idx = 0;
        has_occupied       = 0;
        for i: u32 in 0..MAX_RANGES {
            if count_mask[i] && !has_occupied {
                first_occupied_idx = i[6:0];
                has_occupied       = 1;
            }
        }
    }

    always_comb {
        o_answer   = answer;
        o_busy     = state != State::Idle && state != State::Done;
        o_finished = state == State::Done;
    }
}

#[test(test_day_05)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_05;
        localparam string   FILENAME = "day_05.txt";
        localparam longint  EXPECTED = 64'd14;
        localparam longint  TIMEOUT  = 10000;

        localparam BYTES    = 32;
        localparam IDX_BITS = $clog2(BYTES + 1);

        logic clk, rst;
        longint cycle_count;

        logic [IDX_BITS-1:0] i_available;
        logic [IDX_BITS-1:0] o_consumed;
        logic [BYTES-1:0][7:0] i_data;
        logic i_eof;
        logic o_finished;
        logic [63:0] o_answer;

        aoc_Day05 #(
            .BYTES(BYTES)
        ) dut (
            .clk(clk),
            .rst(rst),
            .i_available(i_available),
            .i_data(i_data),
            .i_eof(i_eof),
            .o_consumed(o_consumed),
            .o_finished(o_finished),
            .o_answer(o_answer)
        );

        initial begin
            clk = 0;
            forever #0.5 clk = ~clk;
        end

        `include "aoc_tasks.svh"

        initial begin
            aoc_init();
            aoc_run_test(FILENAME, TIMEOUT, cycle_count);
            aoc_verify(EXPECTED, cycle_count);
            $finish;
        end
    endmodule
}}}
