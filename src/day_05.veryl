/// Day 5 Part 2: Merge overlapping ranges and count total coverage
///
/// Input format: Lines of "start-end" ranges, followed by blank line, then IDs (ignored).
/// Output: Sum of coverage across all merged disjoint ranges.
///
/// Two ranges overlap or touch if: end1 + 1 >= start2 AND end2 + 1 >= start1
pub module Day05 for ProtoAocSolution (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    var decoder_start      : logic<64>;
    var decoder_end        : logic<64>;
    var decoder_range_valid: logic    ;
    var decoder_done       : logic    ;
    var decoder_busy       : logic    ;
    var solver_busy        : logic    ;
    var solver_valid       : logic    ;

    inst decoder: Day05Decoder (
        clk                               ,
        rst                               ,
        i_data                            ,
        i_valid                           ,
        i_busy       : solver_busy        ,
        o_start      : decoder_start      ,
        o_end        : decoder_end        ,
        o_range_valid: decoder_range_valid,
        o_done       : decoder_done       ,
        o_busy       : decoder_busy       ,
    );

    inst solver: Day05Solver (
        clk                               ,
        rst                               ,
        i_start      : decoder_start      ,
        i_end        : decoder_end        ,
        i_range_valid: decoder_range_valid,
        i_done       : decoder_done       ,
        o_answer                          ,
        o_busy       : solver_busy        ,
        o_valid      : solver_valid       ,
    );

    assign o_busy  = decoder_busy;
    assign o_valid = solver_valid;
}

/// Parses "start-end" lines from input stream.
/// Emits (start, end) pairs, signals done after blank line and end of input.
module Day05Decoder (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,
    i_busy : input logic   ,

    o_start      : output logic<64>,
    o_end        : output logic<64>,
    o_range_valid: output logic    ,
    o_done       : output logic    ,
    o_busy       : output logic    ,
) {
    enum State: logic<3> {
        ParseStart,
        ParseEnd,
        EmitRange,
        Consume,
        Done,
    }

    var state     : State    ;
    var start_val : logic<64>;
    var end_val   : logic<64>;
    var prev_valid: logic    ;

    var is_digit  : logic   ;
    var is_dash   : logic   ;
    var is_newline: logic   ;
    var digit_val : logic<4>;

    always_comb {
        is_digit   = i_data >= "0" && i_data <= "9";
        is_dash    = i_data == "-";
        is_newline = i_data == 8'h0A;
        digit_val  = i_data[3:0];
    }

    always_ff {
        if_reset {
            state      = State::ParseStart;
            start_val  = 0;
            end_val    = 0;
            prev_valid = 0;
        } else {
            prev_valid = i_valid;

            case state {
                State::ParseStart: {
                    if i_valid {
                        if is_digit {
                            start_val = start_val * 10 + {60'b0, digit_val};
                        } else if is_dash {
                            state = State::ParseEnd;
                        } else if is_newline && start_val == 0 {
                            state = State::Consume;
                        }
                    }
                }

                State::ParseEnd: {
                    if i_valid {
                        if is_digit {
                            end_val = end_val * 10 + {60'b0, digit_val};
                        } else if is_newline {
                            state = State::EmitRange;
                        }
                    }
                }

                State::EmitRange: {
                    if !i_busy {
                        end_val = 0;

                        // Process incoming character to avoid data loss during handshake
                        if i_valid && is_digit {
                            start_val = {60'b0, digit_val};
                            state     = State::ParseStart;
                        } else if i_valid && is_newline {
                            start_val = 0;
                            state     = State::Consume;
                        } else {
                            start_val = 0;
                            state     = State::ParseStart;
                        }
                    }
                }

                State::Consume: {
                    if !i_valid && prev_valid {
                        state = State::Done;
                    }
                }

                default: {}
            }
        }
    }

    always_comb {
        o_start       = start_val;
        o_end         = end_val;
        o_range_valid = state == State::EmitRange;
        o_done        = state == State::Done;
        o_busy        = state == State::EmitRange && i_busy;
    }
}

/// Merges overlapping ranges and counts total coverage.
/// Maintains up to 128 disjoint ranges in parallel arrays with occupancy bitmask.
module Day05Solver (
    clk: input clock,
    rst: input reset,

    i_start      : input logic<64>,
    i_end        : input logic<64>,
    i_range_valid: input logic    ,
    i_done       : input logic    ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    const MAX_RANGES: u32 = 128;

    enum State: logic<3> {
        Idle,
        ScanOverlap,
        MergeOne,
        FindSlot,
        Insert,
        CountInit,
        CountScan,
        Done,
    }

    var state: State;

    var ranges_start: logic<64>         [MAX_RANGES];
    var ranges_end  : logic<64>         [MAX_RANGES];
    var occupied    : logic<MAX_RANGES>             ;

    var cur_start: logic<64>        ;
    var cur_end  : logic<64>        ;
    var scan_mask: logic<MAX_RANGES>;

    var prev_range_valid  : logic            ;
    var range_valid_rising: logic            ;
    var overlap_mask      : logic<MAX_RANGES>;
    var first_overlap_idx : logic<7>         ;
    var has_overlap       : logic            ;
    var first_empty_idx   : logic<7>         ;
    var has_empty         : logic            ;
    var first_occupied_idx: logic<7>         ;
    var has_occupied      : logic            ;
    var count_mask        : logic<MAX_RANGES>;
    var answer            : logic<64>        ;

    always_comb {
        range_valid_rising = i_range_valid && !prev_range_valid;
    }

    // Overlap detection: ranges overlap or touch if end1+1 >= start2 AND end2+1 >= start1
    always_comb {
        for i: u32       in 0..MAX_RANGES {
            let slot_end_plus1   : logic<64> = ranges_end[i] + 1;
            let cur_end_plus1    : logic<64> = cur_end + 1;
            let overlaps_or_touch: logic     = (slot_end_plus1 >= cur_start) && (cur_end_plus1 >= ranges_start[i]);
            overlap_mask[i]   = occupied[i] && scan_mask[i] && overlaps_or_touch;
        }
    }

    // Priority encoder: first overlapping slot
    always_comb {
        first_overlap_idx = 0;
        has_overlap       = 0;
        for i: u32 in 0..MAX_RANGES {
            if overlap_mask[i] && !has_overlap {
                first_overlap_idx = i[6:0];
                has_overlap       = 1;
            }
        }
    }

    // Priority encoder: first empty slot
    always_comb {
        first_empty_idx = 0;
        has_empty       = 0;
        for i: u32 in 0..MAX_RANGES {
            if !occupied[i] && !has_empty {
                first_empty_idx = i[6:0];
                has_empty       = 1;
            }
        }
    }

    // Priority encoder: first occupied slot (for counting)
    always_comb {
        first_occupied_idx = 0;
        has_occupied       = 0;
        for i: u32 in 0..MAX_RANGES {
            if count_mask[i] && !has_occupied {
                first_occupied_idx = i[6:0];
                has_occupied       = 1;
            }
        }
    }

    always_ff {
        if_reset {
            state            = State::Idle;
            occupied         = 0;
            cur_start        = 0;
            cur_end          = 0;
            scan_mask        = 0;
            count_mask       = 0;
            answer           = 0;
            prev_range_valid = 0;
            ranges_start     = '{default: 0};
            ranges_end       = '{default: 0};
        } else {
            if state == State::Idle {
                prev_range_valid = i_range_valid;
            }

            case state {
                State::Idle: {
                    if range_valid_rising {
                        cur_start        = i_start;
                        cur_end          = i_end;
                        scan_mask        = ~128'b0;
                        state            = State::ScanOverlap;
                        prev_range_valid = 0;
                    } else if i_done {
                        state = State::CountInit;
                    }
                }

                State::ScanOverlap: {
                    if has_overlap {
                        state = State::MergeOne;
                    } else {
                        state = State::FindSlot;
                    }
                }

                State::MergeOne: {
                    let idx: logic<7> = first_overlap_idx;
                    if ranges_start[idx] <: cur_start {
                        cur_start = ranges_start[idx];
                    }
                    if ranges_end[idx] >: cur_end {
                        cur_end = ranges_end[idx];
                    }
                    occupied[idx]  = 0;
                    scan_mask[idx] = 0;
                    state          = State::ScanOverlap;
                }

                State::FindSlot: {
                    if has_empty {
                        state = State::Insert;
                    } else {
                        state = State::Idle;
                    }
                }

                State::Insert: {
                    let idx              : logic<7> = first_empty_idx;
                    ranges_start[idx] = cur_start;
                    ranges_end[idx]   = cur_end;
                    occupied[idx]     = 1;
                    state             = State::Idle;
                }

                State::CountInit: {
                    count_mask = occupied;
                    answer     = 0;
                    state      = State::CountScan;
                }

                State::CountScan: {
                    if has_occupied {
                        let idx            : logic<7>  = first_occupied_idx;
                        let size           : logic<64> = ranges_end[idx] - ranges_start[idx] + 1;
                        answer          = answer + size;
                        count_mask[idx] = 0;
                    } else {
                        state = State::Done;
                    }
                }

                default: {}
            }
        }
    }

    always_comb {
        o_answer = answer;
        o_busy   = state != State::Idle && state != State::Done;
        o_valid  = state == State::Done;
    }
}

#[test(test_day_05)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_05;
        `include "aoc_tasks.svh"

        // Standard AoC signals
        logic clk;
        logic rst;
        logic [7:0] i_data;
        logic       i_valid;
        logic [63:0] o_answer;
        logic        o_busy;
        logic        o_valid;

        // Cycle counter
        longint cycle_count;
        logic counting;

        aoc_Day05 dut (
            .clk      (clk),
            .rst      (rst),
            .i_data   (i_data),
            .i_valid  (i_valid),
            .o_answer (o_answer),
            .o_busy   (o_busy),
            .o_valid  (o_valid)
        );

        // Clock generation (1 GHz = 1ns period)
        initial clk = 0;
        always #0.5 clk = ~clk;

        // Cycle counter: count from first i_valid to o_valid
        initial begin
            cycle_count = 0;
            counting = 0;
        end
        always @(posedge clk) begin
            if (i_valid && !counting) counting <= 1;
            if (counting && !o_valid) cycle_count <= cycle_count + 1;
        end

        // Test block: stream file, wait for result, assert answer
        initial begin
            aoc_init();
            aoc_reset();
            aoc_stream_file("day_05.txt");
            while (!o_valid) @(posedge clk);
            $display("[AoC] Final Answer: %0d", o_answer);
            $display("[AoC] Cycles: %0d (%.3f ms at 1 GHz)", cycle_count, cycle_count / 1000000.0);
            assert (o_answer == 64'd14) else $error("Answer mismatch: expected %0d, got %0d", 64'd14, o_answer);
            $finish;
        end

        // Timeout block: fail after 1 second
        initial begin
            #1000000000;
            $error("Timeout: test did not complete within 1 second");
            $finish;
        end
    endmodule
}}}
