pub module Day01 #(
    param BYTES: u32 = 1,
) (
    clk: input clock,
    rst: input reset,

    i_data     : input  logic<BYTES, 8>          ,
    i_available: input  logic<$clog2(BYTES + 1)> ,
    o_consumed : output logic<$clog2(BYTES + 1)> ,
    o_finished : output logic                    ,
    o_answer   : output logic<64>                ,
) {
    // Map new interface to internal signals
    let i_byte : logic<8> = i_data[0];
    let i_valid: logic    = i_available != 0;
    var o_busy : logic;

    // Track if we've seen input and if it has stopped
    var seen_input   : logic;
    var input_stopped: logic;
    var prev_valid   : logic;

    always_ff {
        if_reset {
            seen_input    = 0;
            input_stopped = 0;
            prev_valid    = 0;
        } else {
            prev_valid = i_valid;
            if i_valid {
                seen_input = 1;
            }
            if seen_input && prev_valid && !i_valid {
                input_stopped = 1;
            }
        }
    }

    // Output mapping
    always_comb {
        o_consumed = i_available;
        if o_busy {
            o_consumed = 0;
        }
        o_finished = decoder_done && solver_valid && !decoder_valid;
    }

    // Internal signals
    var count: logic<32>;
    var right: logic    ;

    // Control signals (between decoder and solver)
    var decoder_valid: logic;
    var decoder_done : logic;
    var solver_busy  : logic;
    var solver_valid : logic;

    inst decoder: Day01Decoder (
        clk                         ,
        rst                         ,
        i_busy         : solver_busy,
        i_data         : i_byte     ,
        i_valid                     ,
        i_input_stopped: input_stopped,
        o_busy                      ,
        o_count        : count      ,
        o_right        : right      ,
        o_valid        : decoder_valid,
        o_done         : decoder_done,
    );

    inst solver: Day01Solver (
        clk                    ,
        rst                    ,
        i_count : count        ,
        i_right : right        ,
        i_valid : decoder_valid,
        o_answer               ,
        o_busy  : solver_busy  ,
        o_valid : solver_valid ,
    );
}

module Day01Decoder (
    clk: input clock,
    rst: input reset,

    i_busy         : input logic   ,
    i_data         : input logic<8>,
    i_valid        : input logic   ,
    i_input_stopped: input logic   ,

    o_busy : output logic    ,
    o_count: output logic<32>,
    o_right: output logic    ,
    o_valid: output logic    ,
    o_done : output logic    ,
) {
    enum State: logic<2> {
        Search,
        Parse,
        Finish,
        Done,
    }

    var state: State    ;
    var count: logic<32>;
    var right: logic    ;
    var valid: logic    ;
    var busy : logic    ;

    always_ff {
        if_reset {
            state = State::Search;
            count = 0;
            right = 0;
            valid = 0;
            busy  = 0;
        } else {
            case state {
                State::Search: {
                    if i_valid {
                        right = (i_data == 8'h52); // 'R'
                        state = State::Parse;
                    } else if i_input_stopped {
                        state = State::Done;
                    }
                }

                State::Parse: {
                    if i_valid {
                        switch {
                            i_data == 8'h0A: { // '\n'
                                busy  = 1;
                                valid = 1;
                                state = State::Finish;
                            }

                            i_data >= 8'h30 && i_data <= 8'h39: {
                                count = (count * 10) + {24'0, (i_data - 8'h30)};
                            }
                        }
                    } else if i_input_stopped && count != 0 {
                        // Input ended without newline - emit final entry
                        busy  = 1;
                        valid = 1;
                        state = State::Finish;
                    } else if i_input_stopped {
                        state = State::Done;
                    }
                }

                State::Finish: {
                    if !i_busy {
                        busy  = 0;
                        count = 0;
                        valid = 0;
                        if i_input_stopped {
                            state = State::Done;
                        } else {
                            state = State::Search;
                        }
                    }
                }

                State::Done: {}

                default: {}
            }
        }
    }

    assign o_busy  = busy;
    assign o_count = count;
    assign o_right = right;
    assign o_valid = valid;
    assign o_done  = state == State::Done;
}

module Day01Solver (
    clk: input clock,
    rst: input reset,

    i_count: input logic<32>,
    i_right: input logic    ,
    i_valid: input logic    ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    const START_POSITION: logic<7> = 50;

    var answer: logic<64>;
    var state : logic<7> ; // 0-99 fits in 7 bits

    // Combinational: closed-form solution
    var dist_to_zero : logic<7> ; // Distance to next zero (1-100)
    var clicks       : logic<4> ; // Clicks for this command (0-10)
    var new_state    : logic<7> ; // State after this command
    var raw_new_state: logic<11>; // State +/- count before modulo (0-1099)
    var quotient     : logic<4> ; // floor(raw_new_state / 100)
    var clicks_diff  : logic<11>; // For clicks calculation

    always_comb {
        // Distance to next zero in direction of travel
        if state == 0 {
            dist_to_zero = 7'd100; // At zero: next zero is a full lap away
        } else if i_right {
            dist_to_zero = 7'd100 - state; // Going right: wrap through 99->0
        } else {
            dist_to_zero = state; // Going left: direct path to 0
        }

        if i_right {
            raw_new_state = {4'b0, state} + i_count[10:0];
        } else {
            // Add 1000 to avoid negative values
            raw_new_state = {4'b0, state} + 11'd1000 - i_count[10:0];
        }

        // Integer division by 100 to get quotient q
        if raw_new_state >= 11'd1000 {
            quotient = 4'd10;
        } else if raw_new_state >= 11'd900 {
            quotient = 4'd9;
        } else if raw_new_state >= 11'd800 {
            quotient = 4'd8;
        } else if raw_new_state >= 11'd700 {
            quotient = 4'd7;
        } else if raw_new_state >= 11'd600 {
            quotient = 4'd6;
        } else if raw_new_state >= 11'd500 {
            quotient = 4'd5;
        } else if raw_new_state >= 11'd400 {
            quotient = 4'd4;
        } else if raw_new_state >= 11'd300 {
            quotient = 4'd3;
        } else if raw_new_state >= 11'd200 {
            quotient = 4'd2;
        } else if raw_new_state >= 11'd100 {
            quotient = 4'd1;
        } else {
            quotient = 4'd0;
        }


        // new_state = raw_new_state mod 100 = raw_new_state - 100q
        // 100q = (64 + 32 + 4) * q = (q << 6) + (q << 5) + (q << 2)
        var q_times_100: logic<11>;

        q_times_100 = {quotient, 6'b0} + {1'b0, quotient, 5'b0} + {4'b0, quotient, 2'b0};
        new_state   = raw_new_state[6:0] - q_times_100[6:0];

        // The number of clicks at/through zero is given by:
        // 1 + floor((count - dist_to_zero) / 100) if count >= dist_to_zero, else 0
        clicks_diff = {1'b0, i_count[9:0]} - {4'b0, dist_to_zero};

        if i_count[9:0] <: {3'b0, dist_to_zero} {
            clicks = 0;
        } else if clicks_diff >= 11'd900 {
            clicks = 4'd10;
        } else if clicks_diff >= 11'd800 {
            clicks = 4'd9;
        } else if clicks_diff >= 11'd700 {
            clicks = 4'd8;
        } else if clicks_diff >= 11'd600 {
            clicks = 4'd7;
        } else if clicks_diff >= 11'd500 {
            clicks = 4'd6;
        } else if clicks_diff >= 11'd400 {
            clicks = 4'd5;
        } else if clicks_diff >= 11'd300 {
            clicks = 4'd4;
        } else if clicks_diff >= 11'd200 {
            clicks = 4'd3;
        } else if clicks_diff >= 11'd100 {
            clicks = 4'd2;
        } else {
            clicks = 4'd1;
        }
    }

    always_ff {
        if_reset {
            answer = 0;
            state  = START_POSITION;
        } else if i_valid {
            answer = answer + {60'b0, clicks};
            state  = new_state;
        }
    }

    assign o_answer = answer;
    assign o_busy   = 0; // Single-cycle, never busy
    assign o_valid  = 1; // Always valid
}

#[test(test_day_01)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_01;
        localparam string   FILENAME = "day_01.txt";
        localparam longint  EXPECTED = 64'd6;
        localparam longint  TIMEOUT  = 100000;

        localparam BYTES    = 1;
        localparam IDX_BITS = $clog2(BYTES + 1);

        logic clk, rst;
        longint cycle_count;

        logic [BYTES-1:0][7:0] i_data;
        logic [IDX_BITS-1:0] i_available;
        logic [IDX_BITS-1:0] o_consumed;
        logic o_finished;
        logic [63:0] o_answer;

        aoc_Day01 #(
            .BYTES(BYTES)
        ) dut (
            .clk(clk),
            .rst(rst),
            .i_data(i_data),
            .i_available(i_available),
            .o_consumed(o_consumed),
            .o_finished(o_finished),
            .o_answer(o_answer)
        );

        initial begin
            clk = 0;
            forever #0.5 clk = ~clk;
        end

        `include "aoc_tasks.svh"

        initial begin
            aoc_init();
            aoc_run_test(FILENAME, TIMEOUT, cycle_count);
            aoc_verify(EXPECTED, cycle_count);
            $finish;
        end
    endmodule
}}}
