pub module Day01 for ProtoAocSolution (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    // Internal signals
    var count: logic<32>;
    var right: logic    ;

    // Control signals (between decoder and solver)
    var decoder_valid: logic;
    var solver_busy  : logic;
    var solver_valid : logic;

    inst decoder: Day01Decoder (
        clk                   ,
        rst                   ,
        i_busy : solver_busy  ,
        i_data                ,
        i_valid               ,
        o_busy                ,
        o_count: count        ,
        o_right: right        ,
        o_valid: decoder_valid,
    );

    inst solver: Day01Solver (
        clk                    ,
        rst                    ,
        i_count : count        ,
        i_right : right        ,
        i_valid : decoder_valid,
        o_answer               ,
        o_busy  : solver_busy  ,
        o_valid : solver_valid ,
    );

    assign o_valid = solver_valid && !decoder_valid && !i_valid;
}

module Day01Decoder (
    clk: input clock,
    rst: input reset,

    i_busy : input logic   ,
    i_data : input logic<8>,
    i_valid: input logic   ,

    o_busy : output logic    ,
    o_count: output logic<32>,
    o_right: output logic    ,
    o_valid: output logic    ,
) {
    enum State: logic<2> {
        Search,
        Parse,
        Finish,
    }

    var state: State    ;
    var count: logic<32>;
    var right: logic    ;
    var valid: logic    ;
    var busy : logic    ;

    always_ff {
        if_reset {
            state = State::Search;
            count = 0;
            right = 0;
            valid = 0;
            busy  = 0;
        } else {
            case state {
                State::Search: {
                    if i_valid {
                        right = (i_data == 8'h52); // 'R'
                        state = State::Parse;
                    }
                }

                State::Parse: {
                    if i_valid {
                        switch {
                            i_data == 8'h0A: { // '\n'
                                busy  = 1;
                                valid = 1;
                                state = State::Finish;
                            }

                            i_data >= 8'h30 && i_data <= 8'h39: {
                                count = (count * 10) + {24'0, (i_data - 8'h30)};
                            }
                        }
                    }
                }

                State::Finish: {
                    if !i_busy {
                        busy  = 0;
                        count = 0;
                        valid = 0;
                        state = State::Search;
                    }
                }

                default: {}
            }
        }
    }

    assign o_busy  = busy;
    assign o_count = count;
    assign o_right = right;
    assign o_valid = valid;
}

module Day01Solver (
    clk: input clock,
    rst: input reset,

    i_count: input logic<32>,
    i_right: input logic    ,
    i_valid: input logic    ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    var answer: logic<64>;
    var count : logic<32>;
    var right : logic    ;
    var state : logic<32>;

    always_ff {
        if_reset {
            answer = 0;
            count  = 0;
            right  = 0;
            state  = 50;
        } else {
            // Priority 1: If we are busy processing (count > 0)
            if count != 0 {
                count = count - 1;

                if right {
                    // Logic for "Right"
                    if state == 99 {
                        answer += 1;
                        state  =  0;
                    } else {
                        state = state + 1;
                    }
                } else {
                    // Logic for "Left" (Not Right)
                    if state == 1 {
                        answer += 1;
                    }

                    if state == 0 {
                        state = 99;
                    } else {
                        state = state - 1;
                    }
                }

                // Priority 2: Load new data if valid
            } else if i_valid {
                count = i_count;
                right = i_right;
            }
        }
    }

    assign o_answer = answer;
    assign o_busy   = count != 0;
    assign o_valid  = !o_busy;
}

#[test(test_day_01)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_01;
        `include "aoc_tasks.svh"

        // Standard AoC signals
        logic clk;
        logic rst;
        logic [7:0] i_data;
        logic       i_valid;
        logic [63:0] o_answer;
        logic        o_busy;
        logic        o_valid;

        // Cycle counter
        longint cycle_count;
        logic counting;

        aoc_Day01 dut (
            .clk      (clk),
            .rst      (rst),
            .i_data   (i_data),
            .i_valid  (i_valid),
            .o_answer (o_answer),
            .o_busy   (o_busy),
            .o_valid  (o_valid)
        );

        // Clock generation (1 GHz = 1ns period)
        initial clk = 0;
        always #0.5 clk = ~clk;

        // Cycle counter: count from first i_valid to o_valid
        initial begin
            cycle_count = 0;
            counting = 0;
        end
        always @(posedge clk) begin
            if (i_valid && !counting) counting <= 1;
            if (counting && !o_valid) cycle_count <= cycle_count + 1;
        end

        // Test block: stream file, wait for result, assert answer
        initial begin
            aoc_init();
            aoc_reset();
            aoc_stream_file("day_01.txt");
            while (!o_valid) @(posedge clk);
            $display("[AoC] Final Answer: %0d", o_answer);
            $display("[AoC] Cycles: %0d (%.3f ms at 1 GHz)", cycle_count, cycle_count / 1000000.0);
            assert (o_answer == 64'd6) else $error("Answer mismatch: expected %0d, got %0d", 64'd6, o_answer);
            $finish;
        end

        // Timeout block: fail after 1 second
        initial begin
            #1000000000;
            $error("Timeout: test did not complete within 1 second");
            $finish;
        end
    endmodule
}}}
