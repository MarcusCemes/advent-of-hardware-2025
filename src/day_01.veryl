module Day01 (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,

    o_answer: output logic<32>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    var count: logic<32>;
    var right: logic    ;

    var decoder_valid: logic;

    var solver_busy : logic;
    var solver_valid: logic;

    inst decoder: Day01Decoder (
        clk                   ,
        rst                   ,
        i_busy : solver_busy  ,
        i_data                ,
        i_valid               ,
        o_busy                ,
        o_count: count        ,
        o_right: right        ,
        o_valid: decoder_valid,
    );

    inst solver: Day01Solver (
        clk                    ,
        rst                    ,
        i_count : count        ,
        i_right : right        ,
        i_valid : decoder_valid,
        o_answer               ,
        o_busy  : solver_busy  ,
        o_valid : solver_valid ,
    );

    assign o_valid = solver_valid && !decoder_valid && !i_valid;
}

module Day01Decoder (
    clk: input clock,
    rst: input reset,

    i_busy : input logic   ,
    i_data : input logic<8>,
    i_valid: input logic   ,

    o_busy : output logic    ,
    o_count: output logic<32>,
    o_right: output logic    ,
    o_valid: output logic    ,
) {
    var r_busy : logic    ;
    var r_count: logic<32>;
    var r_right: logic    ;
    var r_stage: logic<2> ;
    var r_valid: logic    ;

    var n_busy : logic    ;
    var n_count: logic<32>;
    var n_right: logic    ;
    var n_stage: logic<2> ;
    var n_valid: logic    ;

    always_ff {
        if_reset {
            r_busy  = 0;
            r_count = 0;
            r_right = 0;
            r_stage = 0;
            r_valid = 0;
        } else {
            r_busy  = n_busy;
            r_count = n_count;
            r_right = n_right;
            r_stage = n_stage;
            r_valid = n_valid;
        }
    }

    always_comb {
        n_busy  = r_busy;
        n_count = r_count;
        n_right = r_right;
        n_stage = r_stage;
        n_valid = r_valid;

        case r_stage {
            0: {
                if i_valid {
                    n_right = (i_data == 8'h52); // 'R'
                    n_stage = 1;
                }
            }

            1: {
                if i_valid {
                    switch {
                        i_data == 8'h0A: { // '\n'
                            n_busy  = 1;
                            n_valid = 1;
                            n_stage = 2;
                        }

                        i_data >= 8'h30 && i_data <= 8'h39: { // '0'-'9'
                            n_count = (r_count * 10) + {24'0, (i_data - 8'h30)};
                        }
                    }
                }
            }

            2: {
                if !i_busy {
                    n_busy  = 0;
                    n_count = 0;
                    n_stage = 0;
                    n_valid = 0;
                }
            }
        }
    }

    assign o_busy  = r_busy;
    assign o_count = r_count;
    assign o_right = r_right;
    assign o_valid = r_valid;
}

module Day01Solver (
    clk: input clock,
    rst: input reset,

    i_count: input logic<32>,
    i_right: input logic    ,
    i_valid: input logic    ,

    o_answer: output logic<32>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    var r_answer: logic<32>;
    var r_count : logic<32>;
    var r_valid : logic    ;
    var r_right : logic    ;
    var r_state : logic<32>;

    var n_answer: logic<32>;
    var n_count : logic<32>;
    var n_valid : logic    ;
    var n_right : logic    ;
    var n_state : logic<32>;

    always_ff {
        if_reset {
            r_answer = 0;
            r_count  = 0;
            r_right  = 0;
            r_state  = 50;
            r_valid  = 0;
        } else {
            r_answer = n_answer;
            r_count  = n_count;
            r_valid  = n_valid;
            r_right  = n_right;
            r_state  = n_state;
        }
    }

    always_comb {
        n_answer = r_answer;
        n_count  = r_count;
        n_right  = r_right;
        n_state  = r_state;
        n_valid  = r_valid;

        if r_count != 0 {
            n_count = r_count - 1;

            if r_right {

                if r_state == 99 {
                    n_answer = r_answer + 1;
                    n_state  = 0;
                } else {
                    n_state = r_state + 1;
                }

            } else {

                if r_state == 1 {
                    n_answer = r_answer + 1;
                }

                if r_state == 0 {
                    n_state = 99;
                } else {
                    n_state = r_state - 1;
                }

            }
        } else if i_valid {
            n_count = i_count;
            n_right = i_right;
        }
    }

    assign o_answer = r_answer;
    assign o_busy   = r_count != 0;
    assign o_valid  = !o_busy;
}

#[test(test_day_01)]
embed (inline) sv{{{
    module test_day_01;
        logic clk;
        logic rst;

        logic [7:0] i_data;
        logic       i_valid;

        logic [31:0] o_answer;
        logic        o_busy;
        logic        o_valid;

        aoc_Day01 dut (
            .clk    (clk),
            .rst    (rst),
            .i_data   (i_data),
            .i_valid  (i_valid),
            .o_answer (o_answer),
            .o_busy   (o_busy),
            .o_valid  (o_valid)
        );

        initial clk = 0;
        always #5 clk = ~clk;

        int fd;
        int char_in;

        initial begin
            $dumpfile("wave.vcd");
            $dumpvars(0, test_day_01);

            rst = 0;
            i_valid = 0;
            i_data = 0;

            #20;
            rst = 1;
            #10;

            fd = $fopen("day_01.txt", "rb");
            assert (fd != 0) else $error("Failed to open input file");

            @(negedge clk);
            i_valid = 1;

            while (!$feof(fd)) begin
                char_in = $fgetc(fd);

                if (char_in != -1) begin
                    i_data  = 8'(char_in);
                    @(negedge clk);

                    while (o_busy == 1) begin
                        @(negedge clk);
                    end

                end
            end

            i_data  = 8'h0A; // '\n'
            @(negedge clk);
            i_valid = 0;

            while (!o_valid) begin
                @(negedge clk);
            end

            #100;
            $display("Final Answer: %d", o_answer);
            $finish;
        end
    endmodule
}}}
