/// BinaryHeap keeps the K-smallest nodes for each worker during collection and
/// replays them in ascending order during drain. The module is split into two
/// phases:
///
/// * **Collection (max-heap)**
///   - `o_will_accept` goes high when the heap has space or the incoming node is
///     smaller than the current root, allowing for immediate rejection.
///   - Accepted nodes bubble up like a standard binary heap. When the heap is full,
///     inserting a better candidate replaces the root and bubbles down immediately.
///
/// * **Drain (min-heap)**
///   - When `i_drain` is asserted the heap runs Floyd's heapify bottom-up to turn
///     the stored values into a min-heap.
///   - Once heapify completes, `i_pop` removes the smallest remaining entry and
///     re-exposes the next root.
module BinaryHeap #(
    param SIZE : u32 = 1024,
    param WIDTH: u32 = 64  ,
) (
    clk: input clock,
    rst: input reset,

    i_push       : input  logic       ,
    i_node       : input  logic<WIDTH>,
    i_drain      : input  logic       ,
    i_pop        : input  logic       ,
    o_will_accept: output logic       ,
    o_top        : output logic<WIDTH>,
    o_empty      : output logic       ,
    o_full       : output logic       ,
    o_busy       : output logic       ,
) {
    const CHILD_IDX_LEN: u32 = $clog2(SIZE * 2 + 2);
    const IDX_LEN      : u32 = $clog2(SIZE);
    const SIZE_LEN     : u32 = $clog2(SIZE + 1);

    enum State {
        CollectIdle,
        InsertAtEnd,
        ReplaceRoot,
        BubbleUpA,
        BubbleUpB,
        BubbleDownA,
        BubbleDownB,
        HeapifyInit,
        HeapifyRead,
        HeapifyStart,
        HeapifyNext,
        DrainIdle,
        PopReadLast,
        PopMoveEnd,
    }

    var state      : State;
    var is_min_heap: logic;

    var heap_size  : logic<SIZE_LEN>;
    var current_idx: logic<IDX_LEN> ;
    var heapify_idx: logic<IDX_LEN> ;

    var val_current: logic<WIDTH>;

    var idx_parent : logic<IDX_LEN>      ;
    var idx_left   : logic<CHILD_IDX_LEN>;
    var idx_right  : logic<CHILD_IDX_LEN>;
    var idx_target : logic<IDX_LEN>      ;
    var swap_needed: logic               ;

    // RAM signals
    var addr_a: logic<IDX_LEN>;
    var addr_b: logic<IDX_LEN>;
    var in_a  : logic<WIDTH>  ;
    var in_b  : logic<WIDTH>  ;
    var we_a  : logic         ;
    var we_b  : logic         ;
    var out_a : logic<WIDTH>  ;
    var out_b : logic<WIDTH>  ;

    inst ram: DualPortRam #(
        SIZE     : SIZE ,
        WORD_SIZE: WIDTH,
    ) (
        clk     : clk   ,
        rst     : rst   ,
        i_addr_a: addr_a,
        i_data_a: in_a  ,
        i_we_a  : we_a  ,
        i_addr_b: addr_b,
        i_data_b: in_b  ,
        i_we_b  : we_b  ,
        o_data_a: out_a ,
        o_data_b: out_b ,
    );

    always_comb {
        idx_parent = (current_idx - 1) >> 1;
        idx_left   = (((current_idx as CHILD_IDX_LEN) << 1) + 1);
        idx_right  = (((current_idx as CHILD_IDX_LEN) << 1) + 2);

        idx_target  = current_idx;
        swap_needed = 0;

        case state {
            State::BubbleUpB: {
                if current_idx >: 0 && out_a <: val_current {
                    swap_needed = 1;
                    idx_target  = idx_parent;
                }
            }

            State::BubbleDownB: {
                let has_left       : logic = (idx_left <: (heap_size as CHILD_IDX_LEN));
                let has_right      : logic = (idx_right <: (heap_size as CHILD_IDX_LEN));
                var target_is_left : logic;
                var target_is_right: logic;

                target_is_left  = 0;
                target_is_right = 0;

                if !is_min_heap { // Max Heap
                    if has_left && out_a >: val_current {
                        if has_right && out_b >: out_a {
                            target_is_right = 1;

                        } else {
                            target_is_left = 1;
                        }

                    } else if has_right && out_b >: val_current {
                        target_is_right = 1;
                    }

                } else { // Min Heap
                    if has_left && out_a <: val_current {
                        if has_right && out_b <: out_a {
                            target_is_right = 1;

                        } else {
                            target_is_left = 1;
                        }

                    } else if has_right && out_b <: val_current {
                        target_is_right = 1;
                    }
                }

                if target_is_left {
                    idx_target  = idx_left as IDX_LEN;
                    swap_needed = 1;

                } else if target_is_right {
                    idx_target  = idx_right as IDX_LEN;
                    swap_needed = 1;
                }

            }
            default: {}
        }
    }

    always_ff {
        if_reset {
            heap_size   = '0;
            state       = State::CollectIdle;
            is_min_heap = 0;
            current_idx = '0;
            heapify_idx = '0;
            val_current = '0;

        } else {
            case state {
                State::CollectIdle: {
                    if i_drain {
                        state       = State::HeapifyInit;
                        is_min_heap = 1;

                    } else if i_push {
                        if heap_size <: SIZE {
                            state       = State::InsertAtEnd;
                            current_idx = heap_size as IDX_LEN;
                            val_current = i_node;

                        } else if o_will_accept {
                            state       = State::ReplaceRoot;
                            current_idx = 0;
                            val_current = i_node;
                        }
                    }
                }

                State::InsertAtEnd: {
                    heap_size = heap_size + 1;
                    if current_idx >: 0 {
                        state = State::BubbleUpA;

                    } else {
                        state = State::CollectIdle;
                    }
                }

                State::ReplaceRoot: {
                    state = State::BubbleDownA;
                }

                State::BubbleUpA: {
                    state = State::BubbleUpB;
                }
                State::BubbleUpB: {
                    if swap_needed {
                        current_idx = idx_parent;
                        if current_idx >: 0 {
                            state = State::BubbleUpA;

                        } else {
                            state = State::CollectIdle;
                        }

                    } else {
                        state = State::CollectIdle;
                    }
                }
                State::BubbleDownA: {
                    state = State::BubbleDownB;
                }
                State::BubbleDownB: {
                    if swap_needed {
                        current_idx = idx_target;
                        state       = State::BubbleDownA;

                    } else {
                        if is_min_heap && heapify_idx != '1 {
                            state = State::HeapifyNext;

                        } else if is_min_heap {
                            state = State::DrainIdle;

                        } else {
                            state = State::CollectIdle;
                        }
                    }
                }

                State::HeapifyInit: {
                    if heap_size >: 1 {
                        heapify_idx = ((heap_size >> 1) - 1) as IDX_LEN;
                        state       = State::HeapifyRead;

                    } else {
                        state       = State::DrainIdle;
                        heapify_idx = '1;
                    }
                }
                State::HeapifyRead: {
                    state = State::HeapifyStart;
                }

                State::HeapifyStart: {
                    val_current = out_a;
                    current_idx = heapify_idx;
                    state       = State::BubbleDownA;
                }

                State::HeapifyNext: {
                    if heapify_idx >: 0 {
                        heapify_idx = heapify_idx - 1;
                        state       = State::HeapifyRead;

                    } else {
                        heapify_idx = '1; // Done
                        state       = State::DrainIdle;
                    }
                }

                State::DrainIdle: {
                    if i_pop && heap_size >: 0 {
                        state       = State::PopReadLast;
                        heapify_idx = '1;

                    } else if heap_size == 0 {
                        state       = State::CollectIdle;
                        is_min_heap = 0;
                    }
                }

                State::PopReadLast: {
                    state = State::PopMoveEnd;
                }

                State::PopMoveEnd: {
                    val_current = out_a;
                    heap_size   = heap_size - 1;

                    if heap_size >: 1 {
                        current_idx = 0;
                        state       = State::BubbleDownA;

                    } else {
                        state = State::DrainIdle;
                    }
                }

                default: {}
            }
        }
    }

    always_comb {
        addr_a        = '0;
        addr_b        = '0;
        in_a          = '0;
        in_b          = '0;
        we_a          = 0;
        we_b          = 0;
        o_busy        = 1;
        o_empty       = (heap_size == 0);
        o_full        = (heap_size == SIZE);
        o_will_accept = 0;
        o_top         = out_a;

        case state {
            State::CollectIdle: {
                o_busy = 0;
                addr_a = 0;
                if heap_size <: SIZE {
                    o_will_accept = 1;

                } else {
                    o_will_accept = (i_node <: out_a);
                }
            }

            State::InsertAtEnd: {
                addr_b = heap_size as IDX_LEN;
                in_b   = val_current;
                we_b   = 1;
            }

            State::ReplaceRoot: {
                addr_a = 0;
                in_a   = val_current;
                we_a   = 1;
            }

            State::BubbleUpA: {
                addr_a = idx_parent;
            }

            State::BubbleUpB: {
                if swap_needed {
                    addr_b = current_idx;
                    in_b   = out_a;
                    we_b   = 1;
                    addr_a = idx_parent;
                    in_a   = val_current;
                    we_a   = 1;
                }
            }

            State::BubbleDownA: {
                addr_a = idx_left as IDX_LEN;
                addr_b = idx_right as IDX_LEN;
            }

            State::BubbleDownB: {
                if swap_needed {
                    addr_b = current_idx;

                    if idx_target == (idx_left as IDX_LEN) {
                        in_b = out_a;

                    } else {
                        in_b = out_b;
                    }

                    we_b   = 1;
                    addr_a = idx_target;
                    in_a   = val_current;
                    we_a   = 1;
                }
            }

            State::HeapifyRead: {
                addr_a = heapify_idx;
            }

            State::DrainIdle: {
                o_busy = 0;
                addr_a = 0;
            }

            State::PopReadLast: {
                addr_a = (heap_size - 1) as IDX_LEN;
            }

            State::PopMoveEnd: {
                if heap_size - 1 >: 0 {
                    addr_a = 0;
                    in_a   = out_a;
                    we_a   = 1;
                }
            }

            default: {}
        }
    }

}

#[test(test_binary_heap)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_binary_heap;
        localparam SIZE    = 8;
        localparam WIDTH   = 16;
        localparam PERIOD  = 10;
        localparam TIMEOUT = 100_000;

        typedef logic [WIDTH-1:0] value_t;
        typedef int unsigned model_t[$];

        logic clk;
        logic rst;
        logic     i_push;
        value_t   i_node;
        logic     i_drain;
        logic     i_pop;
        logic     o_will_accept;
        value_t   o_top;
        logic     o_empty;
        logic     o_full;
        logic     o_busy;

        value_t  initial_values[SIZE];
        model_t  model;
        model_t  sorted_model;
        int      accepted;
        int      popped;

        aoc_BinaryHeap #(
            .SIZE (SIZE ),
            .WIDTH(WIDTH)
        ) dut (
            .clk(clk),
            .rst(rst),
            .i_push(i_push),
            .i_node(i_node),
            .i_drain(i_drain),
            .i_pop(i_pop),
            .o_will_accept(o_will_accept),
            .o_top(o_top),
            .o_empty(o_empty),
            .o_full(o_full),
            .o_busy(o_busy)
        );

        initial begin
            clk = 0;
            forever #(PERIOD / 2) clk = ~clk;
        end

        initial begin
            rst      = 0;
            i_push   = 0;
            i_node   = '0;
            i_drain  = 0;
            i_pop    = 0;
            accepted = 0;
            popped   = 0;
            model.delete();
            sorted_model.delete();

            initial_values = '{16'd95, 16'd70, 16'd30, 16'd5, 16'd50, 16'd10, 16'd20, 16'd60};

            repeat (2) @(posedge clk);
            rst = 1;
            @(posedge clk);

            foreach (initial_values[idx]) begin
                push_accept(initial_values[idx]);
            end

            push_reject(16'd200);
            push_accept(16'd15);

            build_sorted_model();
            start_drain();
            drain_all();

            assert(popped == sorted_model.size()) else $fatal("pop count mismatch got %0d", popped);
            $finish;
        end

        task wait_ready();
            while (o_busy) @(posedge clk);
        endtask

        task push_accept(input value_t val);
            wait_ready();
            i_node = val;
            #1;
            assert(o_will_accept) else $fatal("push rejected %0d", val);
            @(posedge clk);
            i_push = 1;
            @(posedge clk);
            i_push = 0;
            i_node = '0;
            accepted++;
            model_insert(val);
        endtask

        task push_reject(input value_t val);
            wait_ready();
            i_node = val;
            #1;
            assert(!o_will_accept) else $fatal("expected reject for %0d", val);
            i_node = '0;
        endtask

        task build_sorted_model();
            sorted_model = model;
            sorted_model.sort();
            assert(sorted_model.size() > 0) else $fatal("sorted model empty");
        endtask

        task start_drain();
            wait_ready();
            @(posedge clk);
            i_drain = 1;
            @(posedge clk);
            i_drain = 0;
            wait_ready();
        endtask

        task drain_all();
            value_t expected;
            for (int idx = 0; idx < sorted_model.size(); idx++) begin
                wait_ready();
                expected = value_t'(sorted_model[idx]);
                assert(o_top == expected)
                    else $fatal("order mismatch expected %0d got %0d", expected, o_top);
                @(posedge clk);
                i_pop = 1;
                @(posedge clk);
                i_pop = 0;
                popped++;
            end
        endtask

        task model_insert(input value_t val);
            int unsigned tmp;
            tmp = val;
            model.push_back(tmp);
            model.sort();
            while (model.size() > SIZE) begin
                void'(model.pop_back());
            end
        endtask

        initial begin
            #(TIMEOUT);
            $fatal("test timeout state=%0d size=%0d", dut.state, dut.heap_size);
        end
    endmodule
}}}
