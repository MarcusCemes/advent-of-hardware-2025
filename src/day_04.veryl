/// Strategy: Store entire grid in registers (padded with zeros).
/// Each iteration, compute neighbour counts for all cells in parallel,
/// identify removable cells (rolls with < 4 neighbors), remove them all
/// simultaneously, and accumulate the count. Repeat until no removals.
pub module Day04 #(
    param BYTES    : u32 = 1 ,
    param GRID_SIZE: u32 = 12,
) (
    clk: input clock,
    rst: input reset,

    i_data     : input  logic<BYTES, 8>         ,
    i_available: input  logic<$clog2(BYTES + 1)>,
    o_consumed : output logic<$clog2(BYTES + 1)>,
    o_finished : output logic                   ,
    o_answer   : output logic<64>               ,
) {
    // Map new interface to internal signals
    let i_byte : logic<8> = i_data[0];
    let i_valid: logic    = i_available != 0;

    // Output mapping - decoder is combinational, never blocks
    always_comb {
        o_consumed = i_available;
        o_finished = solver_valid;
    }

    // Index width: number of bits needed to address GRID_SIZE elements
    // $clog2(12) = 4, $clog2(140) = 8
    const INDEX_WIDTH: u32 = $clog2(GRID_SIZE);

    // Grid storage: array of row vectors (row, col)
    var grid: logic<GRID_SIZE> [GRID_SIZE];

    // Decoder outputs
    var decoder_done: logic             ;
    var decoder_row : logic<INDEX_WIDTH>;
    var decoder_col : logic<INDEX_WIDTH>;
    var decoder_bit : logic             ;
    var decoder_we  : logic             ;

    // Solver signals
    var solver_busy : logic                       ;
    var solver_valid: logic                       ;
    var solver_grid : logic<GRID_SIZE> [GRID_SIZE];

    inst decoder: Day04Decoder #(
        INDEX_WIDTH: INDEX_WIDTH,
    ) (
        clk                  ,
        rst                  ,
        i_data : i_byte      ,
        i_valid              ,
        o_done : decoder_done,
        o_row  : decoder_row ,
        o_col  : decoder_col ,
        o_bit  : decoder_bit ,
        o_we   : decoder_we  ,
    );

    inst solver: Day04Solver #(
        GRID_SIZE: GRID_SIZE,
    ) (
        clk                   ,
        rst                   ,
        i_start : decoder_done,
        i_grid  : grid        ,
        o_grid  : solver_grid ,
        o_answer              ,
        o_busy  : solver_busy ,
        o_valid : solver_valid,
    );

    // Grid update logic (no reset needed)
    always_ff {
        if !decoder_done && decoder_we {
            // During load: set bit at [row][col]
            grid[decoder_row][decoder_col] = decoder_bit;
        } else if solver_busy {
            // During solve: update from solver
            grid = solver_grid;
        }
    }
}

/// Decoder: Parse input stream into grid coordinates
/// Outputs write enable, row, col, and bit value for each '@' or '.' character
module Day04Decoder #(
    param INDEX_WIDTH: u32 = 8,
) (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,

    o_done: output logic             , // Finished loading
    o_row : output logic<INDEX_WIDTH>, // Current row (1-indexed for padding)
    o_col : output logic<INDEX_WIDTH>, // Current col (1-indexed for padding)
    o_bit : output logic             , // Bit to write (1 for @, 0 for .)
    o_we  : output logic             , // Write enable
) {
    var row       : logic<INDEX_WIDTH>;
    var col       : logic<INDEX_WIDTH>;
    var done      : logic             ;
    var prev_valid: logic             ; // To detect falling edge of i_valid

    var is_roll   : logic;
    var is_empty  : logic;
    var is_newline: logic;

    always_comb {
        is_roll    = i_data == 8'h40; // '@'
        is_empty   = i_data == 8'h2E; // '.'
        is_newline = i_data == 8'h0A; // '\n'
    }

    always_ff {
        if_reset {
            row        = 1; // Row and col start at 1 (padded border)
            col        = 1;
            done       = 0;
            prev_valid = 0;
        } else {
            prev_valid = i_valid;

            // Detect end of input: i_valid was high, now low, and we've read at least one row
            if prev_valid && !i_valid && row >: 1 {
                done = 1;
            } else if i_valid && !done {
                if is_newline {
                    row = row + 1;
                    col = 1;
                } else if is_roll || is_empty {
                    col = col + 1;
                }
            }
        }
    }

    always_comb {
        o_done = done;
        o_row  = row;
        o_col  = col;
        o_bit  = is_roll;
        o_we   = i_valid && !done && (is_roll || is_empty);
    }
}

/// Solver: Iteratively remove rolls with < 4 neighbors
/// Uses parallel neighbour computation, but registered popcount for synthesis efficiency
module Day04Solver #(
    param GRID_SIZE: u32 = 12,
) (
    clk: input clock,
    rst: input reset,

    i_start: input logic                       ,
    i_grid : input logic<GRID_SIZE> [GRID_SIZE],

    o_grid  : output logic<GRID_SIZE> [GRID_SIZE],
    o_answer: output logic<64>                   ,
    o_busy  : output logic                       ,
    o_valid : output logic                       ,
) {
    enum State: logic<3> {
        Idle,
        Compute, // Compute removable mask
        Count, // Count removals (registered)
        Apply, // Apply grid update
        Done,
    }

    var state  : State    ;
    var answer : logic<64>;
    var started: logic    ;

    // Removable mask: cell is a roll AND has < 4 neighbors
    var removable: logic<GRID_SIZE> [GRID_SIZE];

    // Registered removal count
    var removal_count: logic<16>;

    // Next grid state after removal
    var next_grid: logic<GRID_SIZE> [GRID_SIZE];

    // Any removable flag (large OR reduction)
    var any_removable: logic;

    // Compute removable mask and next_grid (combinational)
    always_comb {
        any_removable = 0;

        for row: u32 in 0..GRID_SIZE {
            for col: u32 in 0..GRID_SIZE {
                removable[row][col] = 0;
                next_grid[row][col] = i_grid[row][col];
            }
        }

        // Only interior cells can be removed (inside the padding)
        for row: u32 in 1..GRID_SIZE - 1 {
            for col: u32 in 1..GRID_SIZE - 1 {

                var count: logic<4>;

                count = {3'b0, i_grid[row - 1][col - 1]} + {3'b0, i_grid[row - 1][col]} + {3'b0, i_grid[row - 1][col + 1]} + {3'b0, i_grid[row][col - 1]} + {3'b0, i_grid[row][col + 1]} + {3'b0, i_grid[row + 1][col - 1]} + {3'b0, i_grid[row + 1][col]} + {3'b0, i_grid[row + 1][col + 1]};

                if i_grid[row][col] && (count <: 4) {
                    removable[row][col] = 1;
                    next_grid[row][col] = 0;
                    any_removable       = 1;
                }
            }
        }
    }

    always_ff {
        if_reset {
            state         = State::Idle;
            answer        = 0;
            started       = 0;
            removal_count = 0;
        } else {
            case state {
                State::Idle: {
                    if i_start && !started {
                        state         = State::Compute;
                        answer        = 0;
                        started       = 1;
                        removal_count = 0;
                    }
                }

                State::Compute: {
                    removal_count = 0;
                    state         = State::Count;
                }

                // Accumulate the number of removals over one cycle
                // to prevent creating a huge adder tree
                State::Count: {
                    var count_accum: logic<16>;

                    count_accum = 0;

                    for row: u32 in 1..GRID_SIZE - 1 {
                        for col: u32 in 1..GRID_SIZE - 1 {
                            count_accum = count_accum + {15'b0, removable[row][col]};
                        }
                    }

                    removal_count = count_accum;
                    state         = State::Apply;
                }

                State::Apply: {
                    if removal_count == 0 {
                        state = State::Done;
                    } else {
                        answer += {48'b0, removal_count};
                        state  =  State::Compute;
                    }
                }

                default: {}
            }
        }
    }

    always_comb {
        if state == State::Apply && removal_count != 0 {
            o_grid = next_grid;
        } else {
            o_grid = i_grid;
        }
    }

    always_comb {
        o_answer = answer;
        o_busy   = state != State::Idle && state != State::Done;
        o_valid  = state == State::Done;
    }
}

#[test(test_day_04)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_04;
        localparam string   FILENAME = "day_04.txt";
        localparam longint  EXPECTED = 64'd43;
        localparam longint  TIMEOUT  = 100000;

        localparam BYTES    = 1;
        localparam IDX_BITS = $clog2(BYTES + 1);

        logic clk, rst;
        longint cycle_count;

        logic [IDX_BITS-1:0] i_available;
        logic [IDX_BITS-1:0] o_consumed;
        logic [BYTES-1:0][7:0] i_data;
        logic i_eof;
        logic o_finished;
        logic [63:0] o_answer;

        aoc_Day04 #(.BYTES(BYTES)) dut (
            .clk(clk), .rst(rst),
            .i_data(i_data), .i_available(i_available),
            .o_consumed(o_consumed), .o_finished(o_finished),
            .o_answer(o_answer)
        );

        initial begin clk = 0; forever #0.5 clk = ~clk; end

        `include "aoc_tasks.svh"

        initial begin
            aoc_init();
            aoc_run_test(FILENAME, TIMEOUT, cycle_count);
            aoc_verify(EXPECTED, cycle_count);
            $finish;
        end
    endmodule
}}}
