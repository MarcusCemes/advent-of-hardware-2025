/// Architecture: Decoder â†’ Solver with register array
/// - Decoder: parses input, emits digits (for shift regs) or operators (for solver)
/// - Solver: buffers digits in indexed registers, processes on operator receipt
pub module Day06 #(
    param N_ROWS    : u32 = 3 ,
    param LINE_WIDTH: u32 = 16,
) (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    const ROW_IDX_BITS: u32 = $clog2(N_ROWS);

    // Internal signals
    var dec_value    : logic<4>           ;
    var dec_is_digit : logic              ;
    var dec_row      : logic<ROW_IDX_BITS>;
    var dec_valid    : logic              ;
    var dec_busy     : logic              ;
    var solver_busy  : logic              ;
    var solver_answer: logic<64>          ;

    // Track if we've seen any input and if input has stopped
    var seen_input   : logic;
    var input_stopped: logic;
    var prev_valid   : logic;

    inst decoder: Day06Decoder #(
        N_ROWS: N_ROWS,
    ) (
        clk          : clk         ,
        rst          : rst         ,
        i_data       : i_data      ,
        i_valid      : i_valid     ,
        o_value      : dec_value   ,
        o_is_digit   : dec_is_digit,
        o_row        : dec_row     ,
        o_valid      : dec_valid   ,
        i_solver_busy: solver_busy ,
        o_busy       : dec_busy    ,
    );

    inst solver: Day06Solver #(
        N_ROWS    : N_ROWS    ,
        LINE_WIDTH: LINE_WIDTH,
    ) (
        clk       : clk          ,
        rst       : rst          ,
        i_value   : dec_value    ,
        i_is_digit: dec_is_digit ,
        i_row     : dec_row      ,
        i_valid   : dec_valid    ,
        o_busy    : solver_busy  ,
        o_answer  : solver_answer,
    );

    always_ff {
        if_reset {
            seen_input    = 0;
            input_stopped = 0;
            prev_valid    = 0;
        } else {
            prev_valid = i_valid;

            if i_valid {
                seen_input = 1;
            }

            // Input stopped when we had valid input before but not now
            if seen_input && prev_valid && !i_valid {
                input_stopped = 1;
            }
        }
    }

    assign o_answer = solver_answer;
    assign o_busy   = solver_busy || dec_busy;

    // Done when input has stopped and solver is not busy
    assign o_valid = input_stopped && !solver_busy;
}

/// Decoder: Parses input stream, outputs digits or operators
module Day06Decoder #(
    param N_ROWS: u32 = 3,
) (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,

    o_value   : output logic<4>             , // 4-bit digit or 0xF, or operator (0=add, 1=mul)
    o_is_digit: output logic                , // 1 = digit for shift reg, 0 = operator
    o_row     : output logic<$clog2(N_ROWS)>, // Which row (for digit writes)
    o_valid   : output logic                ,

    i_solver_busy: input logic,

    o_busy: output logic,
) {
    const ROW_IDX_BITS: u32 = $clog2(N_ROWS + 1); // +1 for operator row

    var cur_row  : logic<ROW_IDX_BITS>;
    var in_op_row: logic              ;

    // Character classification
    var is_digit  : logic;
    var is_newline: logic;
    var is_plus   : logic;
    var is_mult   : logic;

    always_comb {
        is_digit   = i_data >= 8'h30 && i_data <= 8'h39;
        is_newline = i_data == 8'h0A;
        is_plus    = i_data == 8'h2B;
        is_mult    = i_data == 8'h2A;
        in_op_row  = cur_row == N_ROWS as ROW_IDX_BITS;
    }

    // Backpressure: busy if we have an operator but solver can't accept
    assign o_busy = i_valid && in_op_row && (is_plus || is_mult) && i_solver_busy;

    always_comb {
        o_valid    = 0;
        o_value    = 4'hF;
        o_is_digit = 1;
        o_row      = cur_row[$clog2(N_ROWS) - 1:0];

        if i_valid && !o_busy {
            if in_op_row {
                // Operator row: emit operators to solver
                if is_plus || is_mult {
                    o_valid    = 1;
                    o_is_digit = 0;
                    o_value    = {3'b0, is_mult}; // 0=add, 1=mul
                }

            } else {
                // Digit rows: emit to shift registers
                if !is_newline {
                    o_valid    = 1;
                    o_is_digit = 1;

                    if is_digit {
                        o_value = i_data[3:0];
                    } else {
                        o_value = 4'hF; // whitespace marker
                    }
                }
            }
        }
    }

    always_ff {
        if_reset {
            cur_row = 0;
        } else {
            if i_valid && !o_busy {
                if is_newline {
                    cur_row = cur_row + 1;
                }
            }
        }
    }
}

/// Solver: Receives digits into shift registers, processes on operator receipt
module Day06Solver #(
    param N_ROWS    : u32 = 3 ,
    param LINE_WIDTH: u32 = 16,
) (
    clk: input clock,
    rst: input reset,

    i_value   : input logic<4>             ,
    i_is_digit: input logic                , // 1 = digit for shift reg, 0 = operator
    i_row     : input logic<$clog2(N_ROWS)>, // Which row for digit writes
    i_valid   : input logic                ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
) {
    const ROW_IDX_BITS: u32 = $clog2(N_ROWS);
    const COL_IDX_BITS: u32 = $clog2(LINE_WIDTH);

    // Register storage for each row
    var storage: logic<4> [N_ROWS, LINE_WIDTH];

    // Write column position per row
    var write_cols: logic<COL_IDX_BITS + 1> [N_ROWS];

    var processing: logic                  ; // Currently processing a problem
    var current_op: logic                  ; // 0=add, 1=mul
    var read_col  : logic<COL_IDX_BITS + 1>; // Current read position

    // Accumulator for current problem
    var numbers  : logic<64>               [N_ROWS];
    var num_count: logic<ROW_IDX_BITS + 1>         ;

    var answer: logic<64>;

    assign o_busy   = processing;
    assign o_answer = answer;

    // Check if current column is all whitespace
    var col_all_whitespace: logic    ;
    var col_number        : logic<64>;
    var col_has_digit     : logic    ;

    always_comb {
        col_all_whitespace = 1;
        col_number         = 0;
        col_has_digit      = 0;

        for row: u32 in 0..N_ROWS {

            let d: logic<4> = storage[row][read_col[COL_IDX_BITS - 1:0]];

            if d != 4'hF {
                col_all_whitespace = 0;
                col_number         = col_number * 10 + {60'b0, d};
                col_has_digit      = 1;
            }
        }
    }

    always_ff {
        if_reset {
            storage    = '{default: '{default: 4'hF}};
            write_cols = '{default: 0};
            processing = 0;
            current_op = 0;
            read_col   = 0;
            numbers    = '{default: 0};
            num_count  = 0;
            answer     = 0;
        } else {
            if i_valid {
                if i_is_digit {

                    // Write digit to the appropriate row's register
                    let col_idx: logic<COL_IDX_BITS> = write_cols[i_row][COL_IDX_BITS - 1:0];

                    storage[i_row][col_idx] = i_value;
                    write_cols[i_row]       = write_cols[i_row] + 1;

                } else if !processing {
                    // Operator received - start processing
                    current_op = i_value[0];
                    processing = 1;
                }
            }

            if processing {
                if col_all_whitespace {
                    if num_count >: 0 {
                        var result: logic<64>;

                        result = numbers[0];

                        for i: u32 in 1..N_ROWS {
                            if i <: num_count {
                                if current_op == 0 {
                                    result = result + numbers[i];
                                } else {
                                    result = result * numbers[i];
                                }
                            }
                        }

                        answer += result;
                    }

                    // Done with this problem - advance past separator
                    processing = 0;
                    num_count  = 0;
                    numbers    = '{default: 0};
                    read_col   = read_col + 1; // Skip the whitespace separator column
                } else {
                    // Accumulate column into current number
                    if col_has_digit {
                        numbers[num_count[ROW_IDX_BITS - 1:0]] = col_number;
                        num_count                              = num_count + 1;
                    }

                    read_col = read_col + 1;
                }
            }
        }
    }
}

#[test(test_day_06)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_06;
        `include "aoc_tasks.svh"

        logic clk;
        logic rst;
        logic [7:0] i_data;
        logic       i_valid;
        logic [63:0] o_answer;
        logic        o_busy;
        logic        o_valid;

        longint cycle_count;
        logic counting;

        aoc_Day06 #(
            .N_ROWS(3),
            .LINE_WIDTH(16)
        ) dut (
            .clk      (clk),
            .rst      (rst),
            .i_data   (i_data),
            .i_valid  (i_valid),
            .o_answer (o_answer),
            .o_busy   (o_busy),
            .o_valid  (o_valid)
        );

        initial clk = 0;
        always #0.5 clk = ~clk;

        initial begin
            cycle_count = 0;
            counting = 0;
        end
        always @(posedge clk) begin
            if (i_valid && !counting) counting <= 1;
            if (counting && !o_valid) cycle_count <= cycle_count + 1;
        end

        initial begin
            aoc_init();
            aoc_reset();
            aoc_stream_file("day_06.txt");
            while (!o_valid) @(posedge clk);
            $display("[AoC] Final Answer: %0d", o_answer);
            $display("[AoC] Cycles: %0d (%.3f ms at 1 GHz)", cycle_count, cycle_count / 1000000.0);
            assert (o_answer == 64'd3263827) else $error("Answer mismatch: expected %0d, got %0d", 64'd3263827, o_answer);
            $finish;
        end

        initial begin
            #1000000000;
            $error("Timeout: test did not complete within 1 second");
            $finish;
        end
    endmodule
}}}
