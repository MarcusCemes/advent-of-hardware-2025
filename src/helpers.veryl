/// Find the index of the first occurrence of a delimiter byte in the input data,
/// starting from i_start (inclusive). If not found, returns i_available and o_found=0.
pub module FindDelimiter #(
    param BYTES    : u32      = 32   ,
    param DELIMITER: logic<8> = 8'h0A, // Default: newline
) (
    i_data     : input logic<BYTES, 8>     ,
    i_available: input logic<IDX_BITS>     ,
    i_start    : input logic<IDX_BITS> = '0,

    o_index: output logic<IDX_BITS>,
    o_found: output logic          ,
) {
    const IDX_BITS: u32 = $clog2(BYTES + 1);

    always_comb {
        o_index = i_available;
        o_found = 0;

        // Priority encoder: find first match at or after i_start
        // We iterate backwards so that the lowest index "wins" (last assignment)
        for _i: u32 in 0..BYTES {
            let i: u32 = BYTES - 1 - _i;
            if i as IDX_BITS >= i_start && i as IDX_BITS <: i_available && i_data[i] == DELIMITER {
                o_index = i as IDX_BITS;
                o_found = 1;
            }
        }
    }
}

/// Parse a single unsigned integer from ASCII digits.
/// Reads from i_start up to (but not including) i_end.
/// i_start is the index of the first digit, i_end is the index after the last digit.
pub module ParseNumber #(
    param BYTES      : u32 = 32,
    param MAX_DIGITS : u32 = 5 ,
    param OUTPUT_BITS: u32 = 32,
) (
    i_data : input logic<BYTES, 8>,
    i_start: input logic<IDX_BITS>,
    i_end  : input logic<IDX_BITS>,

    o_value: output logic<OUTPUT_BITS>,
) {
    const IDX_BITS : u32 = $clog2(BYTES + 1);
    const DIGIT_LEN: u32 = $clog2(MAX_DIGITS + 1);

    always_comb {
        o_value = '0;

        // Number of digits to parse
        let n_digits: logic<IDX_BITS> = i_end - i_start;

        // Process each potential digit position
        // We iterate from MSB to LSB (left to right in the string)
        for d: u32 in 0..MAX_DIGITS {
            // Position in buffer: i_start + d
            let pos  : logic<IDX_BITS> = i_start + d as IDX_BITS;
            let digit: logic<4>        = i_data[pos][3:0]; // ASCII '0'-'9' -> 0-9

            if d as IDX_BITS <: n_digits {
                o_value = o_value * 10 + digit as OUTPUT_BITS;
            }
        }
    }
}

/// Parse COUNT comma-separated numbers from a buffer, terminated by DELIMITER.
/// Input: buffer starting at i_offset, containing "num1,num2,...,numN\n"
/// Output: parsed numbers and total bytes consumed (including the delimiter)
pub module ParseNumbers #(
    param BYTES      : u32      = 32   ,
    param COUNT      : u32      = 3    ,
    param DELIMITER  : logic<8> = 8'h0A, // newline
    param MAX_DIGITS : u32      = 5    ,
    param OUTPUT_BITS: u32      = 32   ,
    param SEPARATOR  : logic<8> = 8'h2C, // comma
) (
    i_available: input logic<IDX_BITS>     ,
    i_data     : input logic<BYTES, 8>     ,
    i_offset   : input logic<IDX_BITS> = '0,

    o_consumed: output logic<IDX_BITS>          ,
    o_valid   : output logic                    ,
    o_values  : output logic<COUNT, OUTPUT_BITS>,
) {
    const IDX_BITS: u32 = $clog2(BYTES + 1);

    // Delimiter positions: delim_pos[n] is the position of the n-th delimiter
    // delim_pos[0..COUNT-1] are separator (comma) positions
    // delim_pos[COUNT-1] would be the last separator, but we need the newline too
    // Actually: we need COUNT delimiters total (COUNT-1 commas + 1 newline)
    var delim_pos  : logic<COUNT, IDX_BITS>;
    var delim_found: logic<COUNT>          ;

    // Find all delimiters in one pass using a single always_comb
    always_comb {
        var search_start: logic<IDX_BITS>;
        search_start = i_offset;

        // Find COUNT-1 separators
        for n: u32 in 0..COUNT - 1 {
            delim_pos[n]   = i_available;
            delim_found[n] = 0;

            // Find separator starting from search_start
            for _i: u32 in 0..BYTES {
                let i: u32 = BYTES - 1 - _i;

                if i as IDX_BITS >= search_start && i as IDX_BITS <: i_available && i_data[i] == SEPARATOR {
                    delim_pos[n]   = i as IDX_BITS;
                    delim_found[n] = 1;
                }
            }

            // Next search starts after this separator
            search_start = delim_pos[n] + 1 as IDX_BITS;
        }

        // Find final delimiter (newline)
        delim_pos[COUNT - 1]   = i_available;
        delim_found[COUNT - 1] = 0;

        for _i: u32 in 0..BYTES {
            let i: u32 = BYTES - 1 - _i;

            if i as IDX_BITS >= search_start && i as IDX_BITS <: i_available && i_data[i] == DELIMITER {
                delim_pos[COUNT - 1]   = i as IDX_BITS;
                delim_found[COUNT - 1] = 1;
            }
        }

        // If the final delimiter wasn't found, set its position to i_available
        if !delim_found[COUNT - 1] {
            delim_pos[COUNT - 1] = i_available;
        }

        // Output consumed and valid
        o_consumed = delim_pos[COUNT - 1] + 1 as IDX_BITS;

        o_valid = 1;

        for n: u32 in 0..(COUNT - 1) {
            if !delim_found[n] {
                o_valid = 0;
            }
        }
    }

    // Compute number start/end positions
    var num_start: logic<COUNT, IDX_BITS>;
    var num_end  : logic<COUNT, IDX_BITS>;

    always_comb {
        // First number starts at offset
        num_start[0] = i_offset;
        num_end[0]   = delim_pos[0];

        // Subsequent numbers start after their preceding delimiter
        for n: u32 in 1..COUNT {
            num_start[n] = delim_pos[n - 1] + 1 as IDX_BITS;
            num_end[n]   = delim_pos[n];
        }
    }

    // Parse each number
    for m in 0..COUNT :g_parsers {
        inst parser: ParseNumber #(
            BYTES        ,
            MAX_DIGITS   ,
            OUTPUT_BITS  ,
        ) (
            i_data               ,
            i_start: num_start[m],
            i_end  : num_end[m]  ,
            o_value: o_values[m] ,
        );
    }
}
