/// Algorithm:
/// - First line: find 'S' and set beams[cursor] = 1
/// - Subsequent lines: on '^' with beams[cursor] > 0:
///     beams[cursor-1] += timelines, beams[cursor] = 0, beams[cursor+1] += timelines
/// - Output: combinatorial sum of all beams
///
/// Hardware: 141 parallel 64-bit registers, single-cycle updates per byte
pub module Day07 #(
    param LINE_WIDTH: u32 = 141,
) (
    clk: input clock,
    rst: input reset,

    i_data : input logic<8>,
    i_valid: input logic   ,

    o_answer: output logic<64>,
    o_busy  : output logic    ,
    o_valid : output logic    ,
) {
    const CURSOR_BITS: u32 = $clog2(LINE_WIDTH);

    // Beam registers - each holds timeline count for that column
    var beams: logic<64> [LINE_WIDTH];

    // State
    var cursor    : logic<CURSOR_BITS>;
    var in_init   : logic             ; // true = first line (looking for 'S')
    var done      : logic             ;
    var prev_valid: logic             ;

    // Character classification
    let is_start   : logic = i_data == 8'h53; // 'S'
    let is_splitter: logic = i_data == 8'h5E; // '^'
    let is_newline : logic = i_data == 8'h0A; // '\n'

    // Combinatorial sum of all beams
    var beam_sum: logic<64>;

    always_comb {
        beam_sum = 0;

        for i: u32 in 0..LINE_WIDTH {
            beam_sum += beams[i];
        }
    }

    always_ff {
        if_reset {
            beams      = '{default: 0};
            cursor     = 0;
            in_init    = 1;
            done       = 0;
            prev_valid = 0;
        } else {
            prev_valid = i_valid;

            // Detect end of input
            if prev_valid && !i_valid {
                done = 1;
            }

            if i_valid && !done {
                // Cursor management
                if is_newline {
                    cursor  = 0;
                    in_init = 0; // First newline transitions out of init
                } else {
                    cursor = cursor + 1;
                }

                // Beam updates
                if in_init {
                    if is_start {
                        beams[cursor] = 1;
                    }
                } else {
                    if is_splitter && beams[cursor] >: 0 {
                        let timelines: logic<64> = beams[cursor];

                        beams[cursor - 1] = beams[cursor - 1] + timelines;
                        beams[cursor]     = 0;
                        beams[cursor + 1] = beams[cursor + 1] + timelines;
                    }
                }
            }
        }
    }

    assign o_answer = beam_sum;
    assign o_busy   = 0;
    assign o_valid  = done;
}

#[test(test_day_07)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_07;
        `include "aoc_tasks.svh"

        logic clk;
        logic rst;
        logic [7:0] i_data;
        logic       i_valid;
        logic [63:0] o_answer;
        logic        o_busy;
        logic        o_valid;

        longint cycle_count;
        logic counting;

        aoc_Day07 #(
            .LINE_WIDTH(15)
        ) dut (
            .clk      (clk),
            .rst      (rst),
            .i_data   (i_data),
            .i_valid  (i_valid),
            .o_answer (o_answer),
            .o_busy   (o_busy),
            .o_valid  (o_valid)
        );

        initial clk = 0;
        always #0.5 clk = ~clk;

        initial begin
            cycle_count = 0;
            counting = 0;
        end
        always @(posedge clk) begin
            if (i_valid && !counting) counting <= 1;
            if (counting && !o_valid) cycle_count <= cycle_count + 1;
        end

        initial begin
            aoc_init();
            aoc_reset();
            aoc_stream_file("day_07.txt");
            while (!o_valid) @(posedge clk);
            $display("[AoC] Final Answer: %0d", o_answer);
            $display("[AoC] Cycles: %0d (%.3f ms at 1 GHz)", cycle_count, cycle_count / 1000000.0);
            assert (o_answer == 64'd40) else $error("Answer mismatch: expected %0d, got %0d", 64'd40, o_answer);
            $finish;
        end

        initial begin
            #1000000000;
            $error("Timeout: test did not complete within 1 second");
            $finish;
        end
    endmodule
}}}
