pub module Day07 #(
    param BYTES     : u32 = 32 ,
    param LINE_WIDTH: u32 = 141,
) (
    clk: input clock,
    rst: input reset,

    i_data     : input  logic<BYTES, 8>,
    i_available: input  logic<IDX_BITS>,
    o_consumed : output logic<IDX_BITS>,
    o_finished : output logic          ,
    o_answer   : output logic<64>      ,
) {
    const CURSOR_BITS: u32 = $clog2(LINE_WIDTH);
    const IDX_BITS   : u32 = $clog2(BYTES + 1);

    enum State: logic<2> {
        Init,
        Collect,
        Propagate,
        Done,
    }

    var beams     : logic<64> [LINE_WIDTH];
    var next_beams: logic<64> [LINE_WIDTH];

    var cursor: logic<CURSOR_BITS>;
    var state : State             ;

    var line     : logic<LINE_WIDTH>;
    var next_line: logic<LINE_WIDTH>;

    var s_eol_found: logic          ;
    var s_eol_index: logic<IDX_BITS>;

    var s_start_found: logic          ;
    var s_start_index: logic<IDX_BITS>;

    inst find_delimiter: FindDelimiter #(
        BYTES    : BYTES,
        DELIMITER: 8'h0A, // '\n'
    ) (
        i_data     : i_data     ,
        i_available: i_available,
        o_index    : s_eol_index,
        o_found    : s_eol_found,
    );

    inst find_start: FindDelimiter #(
        BYTES    : BYTES,
        DELIMITER: 8'h53, // 'S'
    ) (
        i_data     : i_data       ,
        i_available: i_available  ,
        o_index    : s_start_index,
        o_found    : s_start_found,
    );

    always_ff {
        if_reset {
            beams  = '{default: '0};
            cursor = '0;
            line   = '0;
            state  = State::Init;

        } else {
            case state {
                State::Init: {
                    if s_start_found {
                        let offset: logic<CURSOR_BITS> = s_start_index as CURSOR_BITS;

                        beams[cursor + offset] = 1;
                    }

                    if s_eol_found {
                        cursor = 0;
                        state  = State::Collect;

                    } else {
                        cursor += i_available as CURSOR_BITS;
                    }
                }

                State::Collect: {
                    line = next_line;

                    if s_eol_found || i_available != BYTES as IDX_BITS {
                        cursor = 0;
                        state  = State::Propagate;

                    } else {
                        cursor += i_available as CURSOR_BITS;
                    }
                }

                State::Propagate: {
                    beams = next_beams;
                    line  = '0;

                    if i_available == 0 {
                        state = State::Done;
                    } else {
                        state = State::Collect;
                    }

                }

                State::Done: {}
            }
        }
    }

    // Compute next beams
    always_comb {
        next_beams = beams;

        for i: u32 in 0..LINE_WIDTH {
            if line[i] == '1 {
                next_beams[i] = 0;

                if i != 0 {
                    next_beams[i - 1] += beams[i];
                }

                if i != LINE_WIDTH - 1 {
                    next_beams[i + 1] += beams[i];
                }
            }
        }

    }

    // Compute next line
    always_comb {
        next_line = line;

        for i: u32 in 0..BYTES {

            var enabled: logic;

            let offset: logic<CURSOR_BITS> = i as CURSOR_BITS;

            enabled = i_data[i] == 8'h5E; // '^'

            if s_eol_found && i >: s_eol_index {
                enabled = 0;
            }

            if enabled {
                next_line[cursor + offset] = 1;
            }
        }
    }

    // Compute the answer
    always_comb {
        o_answer = '0;

        if state == State::Done {
            for j: u32 in 0..LINE_WIDTH {
                o_answer += beams[j];
            }
        }
    }

    // Output signals
    always_comb {
        o_consumed = i_available;
        o_finished = state == State::Done;

        if s_eol_found {
            o_consumed = s_eol_index + 1;
        }

        if state != State::Init && state != State::Collect {
            o_consumed = 0;
        }
    }
}

#[test(test_day_07)]
embed (inline) sv{{{
    `timescale 1ns/1ps

    module test_day_07;
        localparam string   FILENAME = "day_07.txt";
        localparam longint  EXPECTED = 64'd40;
        localparam longint  TIMEOUT  = 10000;

        localparam BYTES    = 32;
        localparam IDX_BITS = $clog2(BYTES + 1);

        logic clk, rst;
        longint cycle_count;

        logic [IDX_BITS-1:0] i_available;
        logic [IDX_BITS-1:0] o_consumed;
        logic [BYTES-1:0][7:0] i_data;
        logic i_eof;
        logic o_finished;
        logic [63:0] o_answer;

        aoc_Day07 #(
            .BYTES(BYTES),
            .LINE_WIDTH(15)
        ) dut (
            .clk(clk),
            .rst(rst),
            .i_data(i_data),
            .i_available(i_available),
            .o_consumed(o_consumed),
            .o_finished(o_finished),
            .o_answer(o_answer)
        );

        initial begin
            clk = 0;
            forever #0.5 clk = ~clk;
        end

        `include "aoc_tasks.svh"

        initial begin
            aoc_init();
            aoc_run_test(FILENAME, TIMEOUT, cycle_count);
            aoc_verify(EXPECTED, cycle_count);
            $finish;
        end
    endmodule
}}}
